There are three general approaches to code splitting available:
    * Entry Points: Manually split code using entry configuration.
    * Prevent Duplication: Use the SplitChunksPlugin to dedupe and split chunks.
    * Dynamic Imports: Split code via inline function calls within modules.

SplitChunksPlugin:
    The SplitChunksPlugin allows us to extract common dependencies into an existing entry chunk or an entirely new chunk.
    * 如果不配置，只会把vendor第三方模块，给split出来，
    * 自己的文件模块并没有被split出来


Dynamic loading:
    Note the use of chunkFilename (output), which determines the name of non-entry chunk files.
    * webpack 会为动态加载的module自动命名，2.bundle.js, 3.bundle.js,
    * 这些动态的 bundle可以合并在一起吗？？？
    * webpack在程序加载新的模块的时候，是通过在head中出入 script 来实现的。

Cache:
    * [contenthash] 加在output.filename中
    *** As you can see the bundle's name now reflects its content (via the hash). 
        If we run another build without making any changes, we'd expect that filename to stay the same. 
        However, if we were to run it again, we may find that this is not the case.
    --- This is because webpack includes certain boilerplate, 
        specifically the runtime and manifest, in the entry chunk.
    *** 但是当
        index依赖 [common-1, common-2]的时候，
        如果仅仅是common-1的内容改变了，index对应的bundle也被重新生成了， cache就被破坏了
        如何避免呢？？optimization.moduleIds = "hashed"

    Extract boilerplate: runtime, menifest
    Module Identifiers; module.id
        * each module.id is incremented based on resolving order by default. 
          Meaning when the order of resolving is changed, the IDs will be changed as well.
    * 尽管抽离了runtime，但是每当有module改变的时候，runtime都会被更新， 但是menifest不会被更新，因为文件名，bundle名和路径都没有变化
